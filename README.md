# SA-FileSystem
### SA-2019-FinalProject
  - A FileSystem consists of two kind of micro-services: datanode & namenode, you can create several datanode services to complete a distributed model.
  - Tried to merge datanode and namenode into one project but failed(See in Repository:https://github.com/NovelistChan/DistributedFileSystem, Error: Bean Not Found)
  - So now you can see two projects: datanode & namenode. Namenode is a Eureka Server with a listener to manage the health condition of datanodes & send requests to datanodes. Datanode is a Eureka Client & it can save blocks in repository. Run several instances(3 in example) in datanode and one instance in namenode then check the interfaces by POSTMAN. （namenode实现为EurekaServer, 又一个EurekaListener可以监听datanode的健康情况，datanode接受namenode发送的请求对block进行管理）
  - Here is the structure of the whole project(namenode & datanode).
```
namenode
├── mvnw
├── mvnw.cmd
├── namenode.iml
├── pom.xml
├── src
│   ├── main
│   │   ├── java
│   │   │   └── czf
│   │   │       └── nju
│   │   │           └── namenode
│   │   │               ├── NamenodeApplication.java
│   │   │               ├── controller
│   │   │               │   └── NameNodeController.java
│   │   │               ├── domain
│   │   │               │   ├── BaseEntity.java
│   │   │               │   ├── Block.java
│   │   │               │   ├── DataNode.java
│   │   │               │   └── Directory.java
│   │   │               ├── listener
│   │   │               │   └── EurekaListener.java
│   │   │               ├── repository
│   │   │               │   ├── DataNodeRepository.java
│   │   │               │   └── DirectoryRepository.java
│   │   │               └── service
│   │   │                   ├── BlockService.java
│   │   │                   ├── DataNodeService.java
│   │   │                   ├── DirectoryService.java
│   │   │                   └── NameNodeService.java
│   │   └── resources
│   │       ├── application.properties
            └── templates
   
```
```
datanode
├── datanode.iml
├── mvnw
├── mvnw.cmd
├── pom.xml
├── src
│   ├── main
│   │   ├── java
│   │   │   └── czf
│   │   │       └── nju
│   │   │           └── datanode
│   │   │               ├── DatanodeApplication.java
│   │   │               ├── controller
│   │   │               │   └── DataNodeController.java
│   │   │               ├── domain
│   │   │               │   ├── BaseEntity.java
│   │   │               │   └── Block.java
│   │   │               ├── repository
│   │   │               │   └── BlockRepository.java
│   │   │               └── service
│   │   │                   └── BlockService.java
│   │   └── resources
│   │       └── application.properties

```
  - modify the application.properties to run 3 instances of datanode:
```
spring.application.name=spring-cloud-datanode1
server.port=9000
eureka.client.serviceUrl.defaultZone=http://localhost:8000/eureka/
```
```
spring.application.name=spring-cloud-datanode2
server.port=9001
eureka.client.serviceUrl.defaultZone=http://localhost:8000/eureka/
```
```
spring.application.name=spring-cloud-datanode3
server.port=9002
eureka.client.serviceUrl.defaultZone=http://localhost:8000/eureka/
```
  - Here are the output-examples displayed by POSTMAN.
    - upload file to /user1 & /user2
    
    - get file directory
    
    - get file in /user1
    
    - download /user1/testfile1 (return the bytes generated by file.getBytes())
    
    - delete /user1/testfile1
    
    - get directory after delete
    
  - Load Balance: When a Block needs to be upload, choose a datanode with fewest blocks to upload to. （每次要上传一个block时，选取负载量最少的datanode来作为block上传的节点）
  
### References
  - http://www.ityouknow.com/ & https://github.com/ityouknow/spring-cloud-examples 
